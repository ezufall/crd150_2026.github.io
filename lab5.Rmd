---
title: "Lab 5: Spatial Data in R"
subtitle: <font size="4">CRD 150 - Quantitative Methods in Community Research</font>
author: Instructor Elise Zufall
date: Feb 4, 2026
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    mathjax: local
    theme: cosmo
    code_folding: show
    self_contained: false
---



<style>
p.comment {
background-color: #DBDBDB;
padding: 10px;
border: 1px solid black;
margin-left: 25px;
border-radius: 5px;
font-style: normal;
}

.figure {
   margin-top: 20px;
   margin-bottom: 20px;
}

h1.title {
  font-weight: bold;
  font-family: Arial;  
}

h2.title {
  font-family: Arial;  
}

</style>


<style type="text/css">
#TOC {
  font-size: 13px;
  font-family: Arial;
}
</style>



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message = FALSE)
```

<br>

In this guide you will acquire the skills needed to process and present spatial data in R.  The objectives of the guide are as follows 


1. Understand how spatial data are processed in R
2. Learn basic data wrangling operations on spatial data
3. Learn how to make a map in R

This lab guide follows closely and supplements the material presented in Chapters 1, 2.1, 2.2, 8 and 9 in the textbook [Geocomputation with R](https://geocompr.robinlovelace.net/) (GWR) and class Handout 5.

<br>

<p class="comment">**Assignment 5 is due by 12:00 pm, Feb 11th on Canvas.**  See [here](https://ezufall.github.io/crd150_2026.github.io/hw_guidelines.html) for assignment guidelines.  You must submit an `.Rmd` file and its associated `.html` file. Name the files: yourLastName_firstInitial_asgn05. For example: zufall_e_asgn05.</p>


<div style="margin-bottom:25px;">
</div>
## **Open up a R Markdown file**
\

Download the [Lab template](https://raw.githubusercontent.com/crd150/data/master/labtemplate.Rmd) into an appropriate folder on your hard drive (preferably, a folder named 'Lab 5'), open it in R Studio, and type and run your code there. The template is also located on Canvas under Files.  Change the title ("Lab 5") and insert your name and date. Don't change anything else inside the YAML (the stuff at the top in between the `---`).  Also keep the grey chunk after the YAML. For a rundown on the use of R Markdown, see the [assignment guidelines](https://ezufall.github.io/crd150_2026.github.io/hw_guidelines.html)

<div style="margin-bottom:25px;">
</div>
## **Installing and loading packages**
\

You’ll need to install the following packages in R. You only need to do this once, so if you’ve already installed these packages, skip the code. Also, don’t put these `install.packages()` commands in your R Markdown document. Copy and paste the code in the R Console. We’ll talk about what functions these packages provide as they come up in the guide.

```{r message = FALSE, warning = FALSE, eval=FALSE}
install.packages("sf")
install.packages("tigris")
install.packages("tmap")
install.packages("RColorBrewer")
```

You’ll need to load the following packages using `library()`. Unlike installing, you will always need to load packages whenever you start a new R session. 

```{r message = FALSE, warning=FALSE}
library(tidyverse)
library(tidycensus)
library(flextable)
library(sf)
library(tigris)
library(tmap)
library(RColorBrewer)
```

<div style="margin-bottom:25px;">
</div>
## **Spatial data in R**
\

The main package we will use for handling spatial data in R is the tidy friendly **sf** package.  **sf** stands for simple features.  What is a feature? A feature is thought of as a thing, or an object in the real world, such as a building or a tree.  A county can be a feature. As can a city and a neighborhood.  Features have a geometry describing where on Earth the features are located, and they have attributes, which describe other properties. Think back to [Lab 3](https://ezufall.github.io/crd150_2026.github.io/lab3.html) - we were working with counties.  The difference between what we were doing then and what we will be doing in this lab is that counties in Lab 3 had attributes (e.g. percent Hispanic, total population), but they did not have geometries. As such, we could not put them on a map because we didn't have their specific geographic coordinates. This is what separates nonspatial and spatial data in R.  

<div style="margin-bottom:25px;">
</div>
## **Bringing in spatial data**
\

**sf** is the specific type of data object that deals with spatial information in R. Think back to [Lab 1](https://ezufall.github.io/crd150_2026.github.io/lab1.html#R_Data_Structures) when we discussed the various ways R stores data - **sf** is just another way.  But please note that spatial data themselves outside of R take on many different formats. We'll be primarily working with shapefiles in this class.  [Shapefiles](https://en.wikipedia.org/wiki/Shapefile) are not the only type of spatial data, but they are the most commonly used. Let's be clear here: **sf** objects are R specific and shapefiles are a general format of spatial data.  This is like tibbles are R specific and csv files are a general format of non spatial data. 

We will be primarily working with census geographic data in this lab and pretty much all future labs. If you need a reminder of the Census geographies, go back to Handout 3. There are two major packages for bringing in Census shapefiles into R: **tidycensus** and **tigris**.  

<div style="margin-bottom:25px;">
</div>
### **tidycensus**
\

In [Lab 3](https://ezufall.github.io/crd150_2026.github.io/lab3.html#Using_the_Census_API), we worked with the **tidycensus** package and the Census API to bring in Census data into R.  Fortunately, we can use the same commands to bring in Census geographic data.  First, load in your Census API key.  If you have not already installed your Census API key, use the function `census_api_key()` and specify `install = TRUE` so that you won't have to run `census_api_key()` again.

```{r eval=FALSE, warning=FALSE, results="hide"}
census_api_key("YOUR API KEY GOES HERE", install = TRUE)
```

Then use the `get_acs()` command to bring in California tract-level median household income, total foreign-born population, and total population from the 5-year 2019-2023 American Community Survey (ACS).  

```{r warning=FALSE, results="hide", message=FALSE}
ca.tracts <- get_acs(geography = "tract", 
              year = 2023,
              variables = c(medincome = "B19013_001", 
                            fb = "B05012_003", totp = "B05012_001"), 
              state = "CA",
              survey = "acs5",
              output = "wide",
              geometry = TRUE)
```

The only difference between the code above and what we used in Lab 3 is we have one additional argument added to the `get_acs()` command: `geometry = TRUE`.  This command tells R to bring in the spatial features associated with the geography you specified in the command, in our case California tracts. You can further narrow your geographic scope to the county level by typing in `county =` as an argument.  For example, to get just Sacramento county tracts, you would type in `county = "Sacramento"`. Type in *ca.tracts* to see what we've got.

```{r}
ca.tracts
```

<br>

The object looks much like a basic tibble, but with a few differences.  

* You'll find that the description of the object now indicates that it is a simple feature collection with 8 fields (attributes or columns of data).  There are 9129 features, in this case, census tracts.
* The Geometry Type indicates that the spatial data are in `MULTIPOLYGON` form (as opposed to points or lines, the other basic vector data forms, which were discussed in Handout 5).  
* The Bounding Box indicates the spatial extent of the features (from left to right, for example, California tracts go from a longitude of -124.4096 to -114.1312).  
* Geodetic CRS is related to the coordinate reference system, which we'll touch on later in the quarter.  
* The final difference is that the data frame contains the column *geometry*.  This geometry is what makes this data frame spatial. Remember that a tibble is a data frame. Hence, an **sf** object is basically a tibble, or has tibble like qualities.  This means that we can use nearly all of the functions we've learned in the past three labs on **sf** objects. Hooray for consistency!

We can find out the object's class

```{r}
class(ca.tracts)
```

Here we find that the object is an *sf* data frame. 

You can also view the object or take a glimpse

```{r}
glimpse(ca.tracts)
```

Remember that "E" at the end of the variable indicates "Estimate" and "M" indicates margin of errors.


<div style="margin-bottom:25px;">
</div> 
### **tigris package**
\

Another package that allows us to bring in census geographic boundaries is **tigris**.  [Here](https://github.com/walkerke/tigris/blob/master/README.md) is a list of all the geographies you can download through this package.  Let's bring in the boundaries for Sacramento city.  Remember from Handout 3 that cities are designated as places by the Census. Use the `places()` function to get all places in California.

```{r warning=FALSE, message=FALSE, results = FALSE}
pl <- places(state = "CA", 
             cb = TRUE, 
             year=2023)
```

<br>

The `cb = TRUE`  argument tells R to download a [generalized cartographic boundary](https://www.census.gov/programs-surveys/geography/technical-documentation/naming-convention/cartographic-boundary-file.html) file, which drastically reduces the size of the data (compare the file size when you don't include `cb = TRUE`).  For example, it eliminates all areas that are strictly covered by water (e.g. lakes).   The argument `year=2023` tells R to bring in the boundaries for that year (census geographies can change from year to year). When using the multi-year ACS, best to use the end year of the period. In the `get_acs()` command above we used `year=2023`, so also use `year=2023` in the `places()` command.  Note that unlike the **tidycensus** package, **tigris** does not allow you to attach attribute data (e.g. Hispanic, total population, etc.) to geometric features. 

Take a glimpse of *pl*.

```{r}
glimpse(pl)
```

We see a *geometry* column, which indicates we have a spatial data frame.

We can use `filter()` to keep Sacramento city. We will filter on the variable *NAME* to keep Sacramento.

```{r warning=FALSE, message=FALSE, results = FALSE}
sac.city <- filter(pl, 
                   NAME == "Sacramento")
```

The argument `NAME == "Sacramento"` tells R to keep cities with the exact city name "Sacramento". Make sure we got what we wanted.

```{r}
glimpse(sac.city)
```


Let's use use the function `counties()` to bring in 2023 county boundaries. 

```{r warning=FALSE, message=FALSE, results = FALSE}
cnty <- counties(state = "CA", 
                 cb = TRUE, 
                 year=2023)
```

Take a look at the data to make sure it contains what we want.

```{r}
glimpse(cnty)
```

To get Sacramento county, we use the `filter()` function. Similar to *pl*, we will filter on the variable *NAME* to keep Sacramento.

```{r}
sac.county <- filter(cnty, 
                     NAME == "Sacramento")
```

If you want to get tract boundaries from *tigris* use the function `tracts()`. Note that in both `tracts()` and `get_acs()`, you can get tracts within a specific county within CA by specifying the `county =` argument. For example, `tracts(state = "CA", county = "Sacramento", cb = TRUE, year=2023)` will yield census tracts in Sacramento county.

Guess what? You earned another badge! Yipee!!


<center>
![](tigris_sticker.png){ width=25% }

</center>

<div style="margin-bottom:25px;">
</div> 
### **Reading from your hard drive**
\

Directly reading spatial files using an API is great, but doesn't exist for many spatial data sources. You'll often have to download a spatial data set, save it onto your hard drive and read it into R.  The function for reading spatial files from your hard drive as **sf** objects is `st_read()`.

Let's bring in two shapefiles I created that contains (1) median housing values for census tracts in Sacramento county from the 2019-2023 ACS and (2) Sacramento county [parks](https://data-sacramentocounty.opendata.arcgis.com/datasets/parks-1/explore).  I zipped up the files and uploaded it onto Github. Make sure your current working directory is pointed to the appropriate folder on your hard drive (use `getwd()` to find out the current working directory and `setwd()` to set it). 

```{r warning = FALSE, message = FALSE}
download.file(url = "https://raw.githubusercontent.com/crd150/data/master/lab5files.zip", 
              destfile = "lab5files.zip")
```

<br>

If you are having problems with the above code, I also uploaded the zip file on Canvas in the Week 5 Lab folder. To manually unzip zipped files on a Mac, check [here](https://support.apple.com/guide/mac-help/zip-and-unzip-files-and-folders-on-mac-mchlp2528/mac). For Windows, check [here](https://support.microsoft.com/en-us/windows/zip-and-unzip-files-f6dde0a7-0fec-8294-e1d3-703ed85e7ebc).

After unzipping the folder, you should see *SacramentoCountyTracts*, *Parks* and *californiatractsrace* files in your current working directory folder. Note that the shapefile is actually not a single file but is represented by multiple files. For *SacramentoCountyTracts*, you should see four files named *SacramentoCountyTracts* with shp, dbf, prj, and shx extensions. These files are all connected to one another, so don't manually alter these files. Only open and alter these files in R.  Moreover, if you want to remove a shapefile from your hard drive, delete all the associated files not just one. For *Parks*, you will see five associated files. We will bring in the non-spatial data file *californiatractsrace.csv* a little later.

Make sure your working directory is now pointed to the *lab5files* folder. Then bring in the Sacramento County tract shapefile using the function `st_read()`, which is from the **sf** package.  You'll need to add the *.shp* extension so that the function knows it's reading in a shapefile.

```{r warning = FALSE, message = FALSE, results = "hide"}
sac.county.tracts <- st_read("SacramentoCountyTracts.shp", 
                             stringsAsFactors = FALSE)
```

The argument `stringsAsFactors = FALSE` tells R to keep any variables that look like a character as a character and not a [factor](https://r4ds.had.co.nz/factors.html), which we won't use much, if at all, in this class.

Take a look

```{r}
glimpse(sac.county.tracts )
```

Has a *geometry* column, so we know it is spatial. Bring in the parks file.

```{r warning = FALSE, message = FALSE, results = "hide"}
parks <- st_read("Parks.shp", 
                 stringsAsFactors = FALSE)
```

Take a look

```{r}
glimpse(parks)
```

What form are these spatial data in?

<div style="margin-bottom:25px;">
</div>
## **Data Wrangling**
\

There is a lot of stuff [behind the curtain](https://r-spatial.github.io/sf/articles/sf1.html) of how R handles spatial data as simple features, but the main takeaway is that **sf** objects are data frames.  This means you can use many of the **tidyverse** functions we've learned in the past couple labs to manipulate **sf** objects, and this includes our best buddy the pipe `%>%` operator.  For example, let's do the following data wrangling tasks on *ca.tracts*.

1. Drop the margins of errors
2. Rename the variables
3. Calculate percent foreign born

We do all of this in one line of continuous code using the pipe operator `%>%`

```{r results='hide'}
ca.tracts <- ca.tracts %>%
            select(-medincomeM, -fbM, -totpM) %>%
            rename(medincome = medincomeE, fb = fbE, totp = totpE) %>%
            mutate(pfb = 100*(fb/totp))
```

Notice that we've already used all of the functions above for nonspatial data wrangling. 

Another important operation is to join attribute data to an **sf** object.  For example, let's say you wanted to add 2019-2023 ACS tract level percent race/ethnicity, which is located in the *californiatractsrace.csv* file we downloaded earlier. Bring this file in using our familiar friend `read_csv()`.

```{r warning=FALSE, message=FALSE}
ca.race <- read_csv("californiatractsrace.csv")
```

Take a look at the dataset

```{r}
glimpse(ca.race)
```

Remember, were dealing with data frames here, so we can use `left_join()`, which we covered in [Lab 3](https://ezufall.github.io/crd150_2026.github.io/lab3.html#Joining_tables), to join the non spatial data frame *ca.race* to the spatial data frame *sac.county.tracts*.

```{r warning=FALSE, message=FALSE}
sac.county.tracts <- sac.county.tracts %>%
  left_join(ca.race, by = "GEOID")
```  

Take a peek

```{r}
glimpse(sac.county.tracts)
```

Note that you cannot join two **sf** objects together using `left_join()`. Always use `left_join()` to join a regular non spatial data frame to a spatial object. For example, you will get an error if you try to join the *ca.tracts* to *sac.county.tracts*

```{r, error=TRUE}
sac.county.tracts <- sac.county.tracts %>%
  left_join(ca.tracts, by = "GEOID")
```  

The error message tells you that you can use the function `st_join()` to join two spatial data objects. We'll learn more about `st_join()` in the next lab.

You can also use the exploratory data analysis functions we learned about in [Lab 4](https://ezufall.github.io/crd150_2026.github.io/lab4.html). For example, what is the correlation between median housing value and percent black?

```{r}
sac.county.tracts %>%
  summarize(Correlation = cor(medhval, pnhblk, use = "complete.obs"))
```  

We get the correlation, but it's not quite as clean as when we calculated descriptive statistics in Lab 4. That's because the resulting object after you do `summarize()` is still a spatial object. To coerce it into a non spatial object, use the function `st_drop_geometry()`, which unsurprisingly drops the object's geometry. This way you can use `flextable()` to create presentation ready tables.

```{r}
sac.county.tracts %>%
  summarize(Correlation = cor(medhval, pnhblk, use = "complete.obs")) %>%
  st_drop_geometry() %>%
  flextable() %>%
  colformat_double(digits = 2) 
```  


The main takeaway: **sf** objects are data frames, so you can use many of the functions you've learned in the past couple of labs on these objects.  Here's a badge!


<center>
![](sf.gif){ width=25% }

</center>


<div style="margin-bottom:25px;">
</div>
## **Saving shapefiles**
\

To save an **sf** object to a file, use the function `st_write()` and specify at least two arguments, the **sf** object you want to save and a file name in quotes with the file extension. You'll also need to specify `delete_layer = TRUE` which overwrites the existing file if it already exists in your current working directory.  Make sure you've set your directory to the folder you want your file to be saved in.  Type in `getwd()` to see your current directory and use `setwd()` to set the directory.

Let's save *sac.county.tracts* as a shapefile named *saccountytractslab5.shp*.  

```{r message=FALSE, results = FALSE}
st_write(sac.county.tracts, 
         "saccountytractslab5.shp", 
         delete_layer = TRUE)
```

Check your current working directory to see if *saccountytractslab5.shp* and its associated files were saved.  

You can save your **sf** object in a number of different data formats other than `shp`.  We won't be concerned too much with these other formats in this class, but you can see a list of them [here](https://www.gdal.org/ogr_formats.html).


<div style="margin-bottom:25px;">
</div>
## **Mapping in R**
\

Now that you've got your spatial data in and wrangled, the next natural step is to map something. There are several functions in R that can be used for mapping.  We won't go through all of them, but GWR outlines in Table 9.1 the range of mapping packages available in R.  The package we'll rely on in this class for mapping is **tmap**.

The foundation function for mapping in **tmap** is `tm_shape()`.  You initiate the spatial data using `tm_shape()`. You then add one or more spatial layers or elements, all taking on the form of `tm_`.  Mapping with **tmap** follows very closely the process for creating graphs with `ggplot()`: initiate the data using `ggplot()`, establish the type of graph using `geom_`, and add options to adjust the features of the graph. 

Let's make a choropleth map of median housing values. Remember that a choropleth map is used to geographically display numeric variables. You first activate the dataset *sac.county.tracts* with `tm_shape()`. This is similar to "activating" your dataset in `ggplot()`.

```{r warning = FALSE, message = TRUE}
tm_shape(sac.county.tracts)
```


You should get a message indicating that there is "nothing to show" because we have not told `tm_shape()` what type of spatial object(s) we want to map. Because we are plotting polygons, we use `tm_polygons()`, which is similar to creating a histogram using `ggplot()` by specifying `geom_histogram()`. If we are plotting points, we will use `tm_dots()` or `tm_symbols()`. If we are plotting lines, we will use `tm_lines()`.  Use the argument `fill = "medhval"` to tell R to shade the tracts by the variable *medhval*.  

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval")
```

You've just created your first map in this class (and perhaps ever). [Hooray!](https://www.youtube.com/watch?v=5pm5QLvHttA) 

**tmap** allows users to specify the classification style with the `fill.scale =` argument. For this argument you will need to specify the `style =` within `tm_scale()`. The default setting uses ‘pretty’ breaks. Let's use `style = "quantile"`, which tells R to break up the shading into quantiles, or equal groups of 5.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile"))
```

The most useful classification styles are described in the bullet points below. 

* `style = pretty`, the default setting, rounds breaks into whole numbers where possible and spaces them evenly
* `style = equal` divides input values into bins of equal range, and is appropriate for variables with a uniform distribution (not recommended for variables with a skewed distribution as the resulting map may end-up having little color diversity)
* `style = quantile` ensures the same number of observations fall into each category (with the potential down side that bin ranges can vary widely)
* `style = jenks` identifies groups of similar values in the data and maximizes the differences between categories
* `style = sd` divides the values by standard deviations above and below the mean.
* `style = cat` was designed to represent categorical values and assures that each category receives a unique color

You can also manually set your own breaks using the argument `breaks =` and then specifying the cutoffs within a vector.

```{r warning = TRUE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(breaks = c(0, 200000, 500000, 750000, 1000000)))
```

Note the message indicating that there are values larger than the highest value specified in the breaks vector, which means the highest (lowest) value in `breaks =` should match or be higher (lower) than the maximum (minimum) value of the variable.  The importance of choosing the appropriate classification scheme is discussed in Handout 5.  You'll get some practice trying out other classification schemes in this week's assignment. Note that **tmap** is smart enough to detect the presence of missing values, and shades them gray and labels them on the legend.

You can overlay multiple features on one map. For example, we can add park polygons on top of county tracts, providing a visual association between parks and median housing values.  Here, we add another `tm_shape()` and `tm_polygons()` to the above code. We use the argument `col = "green"` to color the polygons green.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile")) +
  tm_shape(parks) +
    tm_polygons(col = "green")
```

We will explore the use of `tm_dots()` in a future lab.


<div style="margin-bottom:25px;">
</div>
### **Color Scheme**
\

Don't like the default blue color scheme? We can change the color scheme using the argument `values =` within the `tm_scale()` function. The argument `values =` defines the color ranges associated with the bins as determined by the `style =` argument.  It expects a vector of colors or a new color palette name.  

There are three main groups of color palettes: categorical, sequential and diverging, and each of them serves a different purpose. Categorical palettes consist of easily distinguishable colors and are most appropriate for categorical data (i.e., color patch maps) without any particular order such as urban, suburban and rural, or land cover classes.

The second group is sequential palettes. These follow a gradient, for example from light to dark colors (light colors often tend to represent lower values), and are appropriate for continuous (numeric) variables.  Below we use the color scheme "reds" using `value = "reds"`.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile",
                                    values = "reds"))
```


The third group, diverging palettes, typically range between three distinct colors and are usually created by joining two single-color sequential palettes with the darker colors at each end. Their main purpose is to visualize the difference from an important reference point. For instance, if we used `c(“red”, “blue”)`, the color spectrum would move from red to purple, then to blue, with in between shades. In our example:

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile",
                                    values = c("red","blue")))
```

In order to capture a clearer diverging scale, we insert “white” in between red and blue.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile",
                                    values = c("red","white", "blue")))
```


A preferred approach to select a color palette is to chose one of the schemes contained in the **RColorBrewer** package. These are based on the research of cartographer Cynthia Brewer (see the colorbrewer2 [web site](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3) for details). **RColorBrewer** makes a distinction between sequential scales (for a scale that goes from low to high), diverging scales (to highlight how values differ from a central tendency), and qualitative scales (for categorical variables). For each scale, a series of single hue and multi-hue scales are suggested. In the **RColorBrewer** package, these are referred to by a name (e.g., the “Reds” palette we used above is an example). The full list is contained in the **RColorBrewer** [documentation](https://www.rdocumentation.org/packages/RColorBrewer/versions/1.1-2/topics/RColorBrewer). You should have noticed from the messages produced from the mapping above that  the default "reds" palette is from **RColorBrewer**. You can avoid seeing this message in the future by specifying "brewer.reds" for `values =`.

There are two very useful commands in this package. One sets a color palette by specifying its name and the number of desired categories. The result is a character vector with the hex codes of the corresponding colors.

For example, we select a sequential color scheme going from blue to green, as *BuGn*, by means of the command `brewer.pal`, with the number of categories (5) and the scheme as arguments. The resulting vector contains the HEX codes for the colors.

```{r}
pal <- brewer.pal(5,"BuGn")
pal
```

The command `display.brewer.pal()` allows us to view the color scheme, and explore others, before applying them to a map. For example:

```{r}
display.brewer.pal(5,"BuGn")
```

Using this palette in our map yields the following result.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile",
                                    values = pal))
```


See Ch. 9.2.4 in GWR for a fuller discussion on color and other schemes you can specify.


<div style="margin-bottom:25px;">
</div>
### **Legend**
\

There are many options to change the formatting of the legend. Use the `tm_legend()` function within `tm_polygons()` to change its title, position, orientation, or even disable it. Often, the automatic title for the legend is not intuitive, since it is simply the variable name (in our case, *medhval*). This can be customized by setting the `title =` argument within the `tm_legend()` function.  Let's change the legend title to "Median housing values"

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile",
                                    values = "reds"),
              fill.legend = tm_legend(title = "Median housing values"))
```

Another important aspect of the legend is its positioning. This is handled through the `position =` argument within `tm_legend()`. The default is to position the legend outside of the map frame at the top right. Often, this default solution is appropriate, but sometimes further control is needed.  We can move the legend outside or inside the mapping frame using the functions `tm_pos_out()`, which keeps the legend outside of the map frame and `tm_pos_in()`, which keeps it inside. Within each of these functions, you specify two values that represent the horizontal position ("left", "center", or "right"), and the vertical position ("bottom", "center", or "top"). For example, to move the legend to the bottom right in the inside of the map frame:

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile",
                                    values = "reds"),
              fill.legend = tm_legend(title = "Median housing values",
                                      position = tm_pos_in("right", "bottom")))
```

The legend is too big to fit inside the frame without obscuring some of the map. There are a number of ways to adjust this, but one method is to adjust the overall scale of the map. This will automatically adjust the legend. To adjust the scale, you will need to use the argument `scale =` within the function `tm_layout()`, which is added after the `tm_polygons()` function, and allows you to adjust the overall features of a map. The default scale is 1. When you reduce the scale below 1, the legend shrinks relative to the size of the map. Let's reduce it by 0.6, or 40%.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile",
                                    values = "reds"),
              fill.legend = tm_legend(title = "Median housing values",
                                      position = tm_pos_in("right", "bottom"))) +
  tm_layout(scale = 0.6)
```

If you find the frame around the legend distracting, you can remove it by using the argument `frame =` within `tm_legend()` and setting it to FALSE.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile",
                                    values = "reds"),
              fill.legend = tm_legend(title = "Median housing values",
                                      position = tm_pos_in("right", "bottom"), 
                                      frame = FALSE)) +
  tm_layout(scale = 0.6)
```


We can also customize the background color of the legend, its alignment, font, etc. The `tm_legend()` function has a vast number of options, as detailed in the [documentation](https://r-tmap.github.io/tmap/reference/tm_legend.html).  Also check Ch. 9.2.5 in GWR and the official *tmap* [website](https://r-tmap.github.io/tmap/) for more examples.  

<div style="margin-bottom:25px;">
</div>
### **Title**
\

An important feature that you typically include in a map is the title.  We can set the title of the map using the function `tm_title()`. In addition to setting the title, let's also move the legend back to the outside of the map frame.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile",
                                    values = "reds"),
              fill.legend = tm_legend(title = "Median housing values",
                                      frame = FALSE)) +
  tm_title("2019-2023 Median Housing Values in Sacramento County") +
  tm_layout(scale = 0.6)
```

The default position of the title is at the center outside of the frame. Similar to the legend, you can position the title using the `position =` argument and the functions `tm_pos_in()` and `tm_pos_out()`. For example, the following code moves the the title inside the frame, and positions it center and right:

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile",
                                    values = "reds"),
              fill.legend = tm_legend(title = "Median housing values",
                                      frame = FALSE)) +
  tm_title("2019-2023 Median Housing Values in Sacramento County",
           position = tm_pos_in("center", "top")) +
  tm_layout(scale = 0.6)
```


Not good, so we'll keep it outside.

There are many arguments within `tm_title()` that will allow you to change the font type, color, size and other features of the title.

<div style="margin-bottom:25px;">
</div>
### **Scale bar and arrow**
\

We need to add the other key map components described in Handout 5. Here we add more layout functions after `tm_polygons()` using the `+` operator.  First, the scale bar, which you can add using the function `tm_scalebar()`. Let's also move the title back to the outside of the map frame by removing the `position =` argument

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts) +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile",
                                    values = "reds"),
              fill.legend = tm_legend(title = "Median housing values",
                                      frame = FALSE)) +
  tm_title("2019-2023 Median Housing Values in Sacramento County") +
  tm_scalebar() +
  tm_layout(scale = 0.6)
```

Good start, but let's adjust a few of the features of the scale bar to make it more readable.


```{r}
tm_shape(sac.county.tracts, unit = "mi") +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile",
                                    values = "reds"),
              fill.legend = tm_legend(title = "Median housing values",
                                      frame = FALSE)) +
  tm_title("2019-2023 Median Housing Values in Sacramento County") +
  tm_scalebar(breaks = c(0, 5, 10), text.size  = 1, 
               position = tm_pos_in("right", "bottom")) +
  tm_layout(scale = 0.6)
```

The argument `breaks =` within `tm_scalebar()` tells R the distances to break up and end the bar.  Make sure you use reasonable break points - the Sacramento county area is not, for example, 200 miles wide, so you should not use `c(0,100,200)` (try it and see what happens. You won't like it). Note that the scale is in miles now (were in America!).  The default is in kilometers (the rest of the world!), but you can specify the units within `tm_shape()` using the argument `unit =`.  Here, we used `unit = "mi"` to designate distance in the scale bar measured in miles.  The `position =` argument locates the scale bar on the bottom right of the map. The argument `text.size  =` controls the size of the scale bar.  

<br>

The next element is the north arrow, which we can add using the function `tm_compass()`.  You can control for the type, size and location of the arrow within this function.  We place a 4-star arrow using the `type =` argument at the top left of the map using the `tm_pos_in()` function for the `position =` argument.

```{r warning = FALSE, message = FALSE}
tm_shape(sac.county.tracts, unit = "mi") +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile",
                                    values = "reds"),
              fill.legend = tm_legend(title = "Median housing values",
                                      frame = FALSE)) +
  tm_title("2019-2023 Median Housing Values in Sacramento County") +
  tm_scalebar(breaks = c(0, 5, 10), text.size  = 1, 
               position = tm_pos_in("right", "bottom")) +
  tm_compass(type = "4star", position = tm_pos_in("left", "top")) +
  tm_layout(scale = 0.6)
```

<div style="margin-bottom:25px;">
</div>
### **Other features**
\

One of advantages that **tmap** has over other R mapping packages is that it provides users greater ability to change a variety of settings to make their maps *prettier*. For example, we can eliminate the frame around the map using the argument `frame = FALSE` within `tm_layout()`.  Let's also add back the parks.


```{r warning = FALSE, message = FALSE}
sacmhval.map <- tm_shape(sac.county.tracts, unit = "mi") +
  tm_polygons(fill = "medhval", 
              fill.scale = tm_scale(style = "quantile",
                                    values = "reds"),
              fill.legend = tm_legend(title = "Median housing values",
                                      frame = FALSE)) +
  tm_title("2019-2023 Median Housing Values in Sacramento County") +
  tm_scalebar(breaks = c(0, 5, 10), text.size  = 1, 
               position = tm_pos_in("right", "bottom")) +
  tm_compass(type = "4star", position = tm_pos_in("left", "top")) +
  tm_layout(scale = 0.6, frame = FALSE) +
  tm_shape(parks) +
    tm_polygons(col = "green")

sacmhval.map
```


Notice that we stored the map into an object called *sacmhval.map*.  R is an object-oriented language, so *everything* you *make* in R are objects that can be stored for future manipulation.  This includes maps.  You should see *sacmhval.map* in your Environment window. By storing the map, you can access it anytime during your current R session.

Multiple maps can be arranged in a single plot. You can do this a couple of different ways. First, multiple maps can be defined by specifying multiple data variable names within `tm_polygon()`. For example, to show housing values and percent Hispanic side by side, specify `fill = c("medhval", "phisp")`:

```{r}
tm_shape(sac.county.tracts, unit = "mi") +
  tm_polygons(fill = c("medhval", "phisp"), 
              fill.scale = tm_scale(style = "quantile",
                                    values = "reds"),
              fill.legend = tm_legend(frame = FALSE)) +
  tm_scalebar(breaks = c(0, 5, 10), text.size  = 1, 
               position = tm_pos_in("right", "bottom")) +
  tm_compass(type = "4star", position = tm_pos_in("left", "top")) +
  tm_layout(scale = 0.6, frame = FALSE) +
  tm_shape(parks) +
    tm_polygons(col = "green")
```

You can also use save maps into objects, and arrange them onto a plot using the function `tmap_arrange()`. Let's create the percent Hispanic map, and save it into an object named *sacphisp.map*. 

```{r}
sacphisp.map <-  tm_shape(sac.county.tracts, unit = "mi") +
  tm_polygons(fill = "phisp", 
              fill.scale = tm_scale(style = "quantile",
                                    values = "reds"),
              fill.legend = tm_legend(title = "% Hispanic",
                                      frame = FALSE)) +
  tm_title("2019-2023 Percent Hispanic in Sacramento County") +
  tm_scalebar(breaks = c(0, 5, 10), text.size  = 1, 
               position = tm_pos_in("right", "bottom")) +
  tm_compass(type = "4star", position = tm_pos_in("left", "top")) +
  tm_layout(scale = 0.6, frame = FALSE) +
  tm_shape(parks) +
    tm_polygons(col = "green")
```

Then use `tmap_arrange()` to map *sacmhval.map* and *sacphisp.map* side by side

```{r}
tmap_arrange(sacmhval.map, sacphisp.map)
```

Check the full list of `tm_` elements [here](https://r-tmap.github.io/tmap/reference/index.html).


<div style="margin-bottom:25px;">
</div>    
### **Saving maps**
\

You can save your maps a couple of ways.

1. On the plotting screen where the map is shown, click on *Export* and save it as either an image or pdf file.
2. Use the function `tmap_save()`

For option 2, we can save the map object *sacmhval.map* as such 

```{r warning=FALSE, message=FALSE, eval = FALSE}
tmap_save(sacmhval.map, 
          "saccountyhval.png")
```

Specify the **tmap** object and a filename with an extension. It supports `pdf`, `eps`, `svg`, `wmf`, `png`, `jpg`, `bmp` and `tiff`.  The default is `png`.  Also make sure you've set your directory to the folder that you want your map to be saved in.  

<div style="margin-bottom:25px;">
</div>
### **Interactive maps**
\

So far we've created static maps. That is, maps that don't "move".  But, we're all likely used to Google or Bing maps - maps that we can move around and zoom into.  You can make interactive maps in R using the package **tmap**.  

To make your **tmap** object interactive, use the function `tmap_mode()`. Type in "view" inside this function.

```{r, warning = FALSE, message = FALSE}
tmap_mode("view")
```

Now that the interactive mode has been ‘turned on’, all maps produced with `tm_shape()` will launch. Let's view our saved *sacmhval.map* interactively.

```{r, warning = FALSE, message = FALSE}
sacmhval.map
```

Click on ![](zoom.png) above the map and a larger window should open up. 

Besides interactivity, another important benefit of `tmap_mode()` is that it provides a basemap, which was discussed in Handout 5.  The function of a basemap is to provide background detail necessary to orient the location of the map.  In the static maps we produced earlier, Sacramento county was sort of floating in white space.  As you can see in the interactive map above we've added geographic context to the surrounding area. 

The default basemap in `tmap_mode()` is CartoDB.Positron.  You can change the basemap through the `tm_basemap()` function.  For example, let's change the basemap to an [OpenStreetMap](https://www.openstreetmap.org/).

```{r warning=FALSE, message=FALSE}
sacmhval.map + 
  tm_basemap("OpenStreetMap")
```

For a complete list of basemaps with previews, see [here](http://leaflet-extras.github.io/leaflet-providers/preview/).  There are a lot of cool ones, so please test them out.

You can save your interactive map using the same methods described for static maps. To switch back to plotting mode (noninteractive), type in 

```{r}
tmap_mode("plot")
```

You've completed your introduction to **tmap**. Whew! Badge? Yes, please, you earned it!  Time to [celebrate](https://www.youtube.com/watch?v=3GwjfUFyY6M)!

<center>
![](tmap.png){ width=25% }

</center>


***


<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.


Website created and maintained by [Noli Brazil](https://nbrazil.faculty.ucdavis.edu/) and adapted by [Elise Zufall](https://environmentalpolicy.ucdavis.edu/people/elise-zufall)